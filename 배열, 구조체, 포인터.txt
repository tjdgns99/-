배열(Array) - 기본적으로 제공되는 데이터 타입
	여러 개의 동일한 데이터 타입의 데이터를 한 번에 만들 때 사용된다.
	<인덱스, 요소> 쌍의 집합
	배열의 이름은 포인터(상수 포인터)와 같은 역할
배열의 주소
A[0]	기본주소=base
A[1]	base + 1*sizeof(데이터타입)
  :
A[n]	base + n*sizeof(데이터타입)	

2차원 배열
	가로줄 행(row)와 세로줄 열(column)으로 구성
	A[row][column]
	ex)int A[3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
A[0][0]	기본주소=base
A[0][1]	base + 1*sizeof(데이터타입)
A[0][2]	base + 2*sizeof(데이터타입)
A[0][3]	base + 3*sizeof(데이터타입)
A[1][0]	base + 4*sizeof(데이터타입)
  :
  :
A[2][3]	base + 11*sizeof(데이터타입)
C언어	
	배열의 인덱스는 0에서 시작

행렬(matrix)-배열의 응용(2차원 배열 사용하여 표현)
	희소행렬 - 많은 항들이 0으로 되어있는 행렬
	표현법
		행렬을 전통적인 2차원 배열로 나타내는 것
		0이 아닌 요소만을 (행, 열, 값)으로 나타내는 것

구조체-타입이 다를 수 있는 데이터를 묶는 방법
	구조체를 요소로 가능
	구조체 배열 가능
C언어
struct 구조체명{
	int a;
	float b;
	...
};

struct 구조체명 변수명;

typedef를 사용하여 구조체를 새로운 타입으로 선언 가능
typedef struct 구조체명{

}타입명;

구조체의 대입과 비교연산
	대입 가능
	비교연산 불가능(구조체 변수 VS 구조체 변수)

자체 참조 구조체(self-referential structure)
	구성요소 중 자신을 가리키는 포인터가 한 개 이상 존재하는 구조체
	연결리스트나 트리를 구성할 떄 많이 등장

포인터-다른 변수를 가리킨다.
	포인터 변수(pointer variable)-다른 변수의 주소를 갖고있는 변수
	포인터 변수가 가리키는 메모리의 내용을 추출하거나 변경하려면 *연산자 사용
	char *p;
	p = &a; -> p가 가리키는 곳은 a의 주소이다.
	*p = 'B'; -> p가 가리키는 곳(a)의 값은 'B'이다.

		void *p;		p는 아무것도 가리키지 않는 포인터  -> pi = (int *)p; (void 포인터는 필요할 때마다 다른 포인터로 바꿔 사용 가능
		int *pi;		pi는 정수 변수를 가리키는 포인터
		float *pf;		pf는 실수 변수를 가리키는 포인터
		char *pc;		pc는 문자 변수를 가리키는 포인터
		int **pp;		pp는 포인터를 가리키는 포인터
		struct test *ps;	ps는 test 구조체를 가리키는 포인터
		void (*f)(int)	f는 int를 매개 변수로 갖고 반환 값을 갖지 않는 함수를 가리키는 포인터
	함수의 매개변수로서의 포인터 사용 시 따로 반환하지 않더라고 전달받은 매개변수의 값이 바뀌면 해당 변수의 값도 변경
	int 함수명(int *a)라면
	int b = 5;
	int a = 함수명(&b)로 사용 -> *a = 5

배열과 포인터
	배열이 함수의 매개변수로 전달되면 함수 안에서 배열의 내용을 변경할 수 있다->배열의 이름이 배열의 시작부분을 가리키는 포인터이기 떄문이다.

구조체와 포인터
struct{
	int i;
	float f;
} s, *ps; //struct s와 s구조체를 가리키는 포인터 ps
ps = &s; //ps는 s의 주소를 가리킨다.
ps->i = 2;
ps->f = 3.14;
	'->'는 포인터의 .과 같은 효과를 갖는다 - ps->i하고 (*ps).i는 같다.

포인터의 포인터
	포인터도 하나의 변수이므로 포인터의 포인터 선언 가능
	
함수 포인터
	함수의 주소를 담는 포인터 선언 가능
	함수의 매개변수도 적용시켜서 선언해야함
		void foo(int a, int b)라면
		void (*f)(int, int);
		f = foo;
			foo(10, 20)하고 (*f)(10, 20)은 동일
포인터에 대한 연산
p 		<- 포인터
*p		<- 포인터가 가리키는 값
*p++		<- 포인터가 가리키는 값을 가져온다음 포인터가 한 칸 증가
*p--		<- 포인터가 가리키는 값을 가져온다음 포인터가 한 칸 감소
(*p)++		<- 포인터가 가리키는 값을 증가

주의점
	포인터가 가리키고 있는 값이 없는 경우 NULL로 설정
	포인터가 초기화 안 된 상태에서 포인터가 가리키고 있는 곳에 값을 저장하면 안됨
		
동적 메모리 할당(dynamic memory allocation)
	프로그램 실행 도중 메모리를 할당 받는 것
	필요한 만큼만 할당을 받고 필요한 때에 사용하고 반납할 수 있기 때문에 효율적인 메모리사용가능

	int *pi;
	pi =(int *)malloc(sizeof(int)); //동적 메모리 할당
	...
	free(pi);

	라이브러리
	void *malloc(int size), size 바이트만큼의 메모리 블록을 할당
			  , 새로운 메모리 블록의 시작주소 반환
			  , 메모리 확보가 안되는 경우 NULL을 반환

	void free(void *ptr), 할당받은 메모리를 반환
	void *calloc(int num, int size), 배열요소의 크기는 size바이트이고 개수는 num
				 , 요소들은 0으로 초기화된다., 반환값은 malloc 함수와 동일하다.







